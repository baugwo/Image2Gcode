
package org.lmn.laserRaster.classes
{
	import flash.display.BitmapData;
	import flash.filters.ColorMatrixFilter;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import flash.utils.ByteArray;
	import mx.controls.Text;

	import mx.utils.Base64Encoder;

	import org.lmn.laserRaster.LaserConfiguration;
	import org.lmn.laserRaster.classes.RasterImage;

	public class GCodeEncoder
	{

		static public function generateGCode(incomingBitmap:BitmapData, appliedFilter:ColorMatrixFilter):String
		{
					
			var resolution:Number = LaserConfiguration.RES;
			var pMax:Number = LaserConfiguration.PMAX;
			var pMin:Number = LaserConfiguration.PMIN;
			var powerMax:Number = 255 / (100 / LaserConfiguration.PMAX);
			var powerMin:Number = 255 / (100 / LaserConfiguration.PMIN);
			var burnSpeed:Number = LaserConfiguration.SPD;
			var speed:Number = 10000 / (100 / LaserConfiguration.SPD);
			var xoffset:Number = LaserConfiguration.XOFF;
			var yoffset:Number = LaserConfiguration.YOFF;
			var border:Number = LaserConfiguration.BODR;
			var fname:String = RasterImage.frName;
			var sweep:String = LaserConfiguration.SWEP;
			var gcode:String = ";http://www.toolbotics.com/\r\n\r\n";
			
			var color:uint;
			var red:uint;
			var green:uint;
			var blue:uint;
			var codeLines:uint = 23;
			var bwColor:Number = 0;
			var intensity:uint;
			var xMove:Number = 0;
			var yMove:Number = 0;
			var x:int = 0;
			var y:int = 0;
			var direction:int = 1;
			//var next: int = 0;
			var forward:int = 1;
			var reverse: int = 2;
			var imageWidth:int = 0;
			var imageHeight:int = 0;
			var imageWidthmm:Number = 0;
			var imageHeightmm:Number = 0;
			var counter:int = 0;
			var x1:Number = 0;
			var x2:Number = 0;
			var y1:Number = 0;
			var y2:Number = 0;
			var sweepTotal:int = 0;
			var sweepCounter:int = 0;

			var ba:ByteArray = new ByteArray();

			var encoder:Base64Encoder = new Base64Encoder();
			encoder.insertNewLines = false;

			var myImage:BitmapData = incomingBitmap.clone();
            var output:String;

			myImage.applyFilter(myImage, new Rectangle(0, 0, myImage.width, myImage.height),
					new Point(), appliedFilter);
					
			y = myImage.height;
			imageWidth = myImage.width;
			imageHeight = myImage.height;
			imageWidthmm = imageWidth * resolution;
			imageHeightmm = imageHeight * resolution;
			
			gcode = gcode + ";Generated by Image2Gcode Post Processor GLSR_IMG_1.1\r\n";
			gcode = gcode + ";Image File Name: " + fname + "\r\n";
			gcode = gcode + ";Image Pixels: " + imageWidth + " x " + imageHeight + " (w x h)\r\n";
			gcode = gcode + ";Inter-Pixel Distance: " + resolution + "mm\r\n";
			gcode = gcode + ";Image Size: " + imageWidthmm + " x " + imageHeightmm + "mm (w x h)\r\n";
			gcode = gcode + ";Laser Path Direction: " + sweep + "\r\n";
			gcode = gcode + ";Power Range: " + pMin + " to " + pMax + "%\r\n";
			gcode = gcode + ";XY Burn Speed: " + burnSpeed + "%\r\n\r\n";
			
			gcode = gcode + "M12\r\n";
			gcode = gcode + "G90\r\n";
			gcode = gcode + "M6 T3\r\n";
			gcode = gcode + "M49\r\n";
			gcode = gcode + "M7 S0\r\n";
			gcode = gcode + "M3\r\n";
			gcode = gcode + "M36\r\n";		
			gcode = gcode + "M38 S255\r\n";
			gcode = gcode + "G4 P2000\r\n";			
			gcode = gcode + "M38 S" + toFixed(powerMax, 0) + "\r\n";
			gcode = gcode + "G4 P3000\r\n";
			gcode = gcode + "G1 X" + xoffset + " Y" + yoffset + " F10000\r\n";
			gcode = gcode + "G1 F" + speed + "\r\n";
			
			if (border != 0)
			{				
				while (counter < border)
				{
					x1 = xoffset + (counter * resolution);
					x2 = (xoffset + imageWidthmm) - (counter * resolution);
					y1 = yoffset + (counter * resolution);
					y2 = (yoffset + imageHeightmm) - (counter * resolution);
					
					gcode = gcode + "G1 X" +toFixed(x1, 4) + " Y" +toFixed(y1, 4) + "\r\n";
					gcode = gcode + "G1 X" +toFixed(x2, 4) + " S" + toFixed(powerMax, 0) + "\r\n";
					gcode = gcode + "G1 Y" +toFixed(y2, 4) + "\r\n";
					gcode = gcode + "G1 X" +toFixed(x1, 4) + "\r\n";
					gcode = gcode + "G1 Y" +toFixed(y1, 4) + "\r\n";
					gcode = gcode + "G1 S0\r\n";
					
					counter ++;
					codeLines+=6;
				}				
				
				gcode = gcode + "G1 X" + xoffset + " Y" + yoffset + "\r\n";
			}
			
			xMove = 0;
			yMove = 0;
			
			if (sweep == "Horizontal")
			{
				sweepTotal = imageHeight;
			}
			else if (sweep == "Vertical")
			{
				sweepTotal = imageWidth;
			}
			else if (sweep == "Diagonal")
			{
				sweepTotal = imageWidth + imageHeight;
			}
			
			while (sweepCounter != sweepTotal)
			//while (x < myImage.width || y > 0)
			{
				color = myImage.getPixel(x, y); //scan each pixel in the image
				red = color & 0xFF0000 >> 16;
				green = color & 0x00FF00 >> 8;
				blue = color & 0x0000FF >> 0;
				bwColor = (red + green + blue) / 3; //take the average of the RGB value to get the greyscale
				
				if (sweep == "Horizontal")
				{			
					if (direction == forward && x == imageWidth)
					{
						y --;
						yMove += resolution;
						sweepCounter ++;
						direction = reverse;
					}				
					else if (direction == reverse && x == 0)
					{		
						y --;
						yMove += resolution;
						sweepCounter ++;
						direction = forward;
					}
					else if (direction == forward) 
					{
						x ++;
						xMove += resolution; 
					}				
					else if (direction == reverse) 
					{
						x --;
						xMove -= resolution; 
					}
				}
				else if (sweep == "Vertical")
				{
					if (direction == forward && y == 0)
					{
						x ++;
						xMove += resolution;
						sweepCounter ++;
						direction = reverse;
					}				
					else if (direction == reverse && y == imageHeight)
					{		
						x ++;
						xMove += resolution;
						sweepCounter ++;
						direction = forward;
					}
					else if (direction == forward) 
					{
						y --;
						yMove += resolution; 
					}				
					else if (direction == reverse) 
					{
						y ++;
						yMove -= resolution; 
					}
				}
				else if (sweep == "Diagonal")
				{
					
					if (direction == forward && x == 0 && y != 0)
					{
						y --;
						yMove += resolution;
						sweepCounter ++;
						direction = reverse;						
					}
					else if (direction == forward && y == 0)
					{
						x ++;
						xMove += resolution;
						sweepCounter ++;
						direction = reverse;						
					}
					else if (direction == reverse && y == imageHeight && x != imageWidth)
					{
						x ++;
						xMove += resolution;
						sweepCounter ++;
						direction = forward;						
					}
					else if (direction == reverse && x == imageWidth)
					{
						y --;
						yMove += resolution;
						sweepCounter ++;
						direction = forward;						
					}
					else if (direction == reverse)
					{
						y ++;
						yMove -= resolution;
						x ++;
						xMove += resolution;						
					}
					else if (direction == forward)
					{
						y --;
						yMove += resolution;
						x --;
						xMove -= resolution;						
					}
				}
									
				var power:int;
				
				intensity = 255 - bwColor; //inverse so darker is higher value
						
				if (intensity < 3) 
				{
					intensity = 0;
				}
					
				power = (intensity / 255) * (powerMax - powerMin) + powerMin;
					
				var movex:Number = xMove + xoffset;
				var movey:Number = yMove + yoffset;
					
				gcode = gcode + "G1 X" +toFixed(movex, 4) + " Y" +toFixed(movey, 4) + " S" + power + "\r\n";
						
				codeLines++;				
			}
			
			gcode = gcode + "M7 S0\r\n";
			gcode = gcode + "M37\r\n";
			gcode = gcode + "M5\r\n";
			gcode = gcode + "M38 S0\r\n";
			gcode = gcode + "M2\r\n";
			gcode = gcode + ";(Code Lines: " + codeLines + ")\r\n";

			return gcode;
		}
		
		static public function toFixed(number:Number, precision:int):Number
		{
				precision = Math.pow(10, precision);
				return Math.round(number * precision) / precision;
		}
		

	}
}
